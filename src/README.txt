Name: Naveenraj Nagarathinam(CSE\nagarath)
nagarathinam.1@osu.edu

Compiling and executing the interpreter:
1. Open the location containing the source files
2. To compile: run 'make'
3. To run(after compiling): java Interpreter < path_to_input_file > path_to_output_file

Implementation details:
Flow of control:
The interpreter executes in a Read-Eval-Print loop. When executed, the control first flows to the Parser, which controls the Read-Eval-Print loop. Let us call this the controller. It triggers parsing, which starts by looking for the non-terminal 'E' in the input. The parser gets the next token from the tokenizer as and when needed. When the tokenizer runs out of tokens, it gets the next input line from the scanner, tokenizes the input and gets ready to provide tokens to the parser. Once the parser finds a complete SExpression, it then returns to the controller, which then triggers the evaluation of the SExpression. The evaluator executes the appropriate methods taking help from inbuilt function hanlder whenever required and produces the result of execution to the controller, which then gets the helper print the result to stdout. The controller then triggers the parser again to look for any remaining input to process. Any error in the lifetime of the Read-Eval-Print loop is thrown back immediately to the controller, which is printed to stdout and the control exits back to the OS.

Scanner, Tokenizer and Parser:
Parser parses the input using the LL(1) grammar provided in the project description. It gets tokens from tokenizer whenever required. When an unexpected token is encountered, it denotes a syntctic error in the input and is thrown back to the controller. When a token is expected by the parser and the tokenizer is out of tokens, it means that the SExpression in the input is incomplete; the error is thrown back to the controller. The tokenizer maintains a list of tokens to be processed, which is provided to the parser upon request one at a time. When there are no pending tokens, it calls the scanner to get the next input line. If it turns out to be an empty line, the scanner is polled for input until a non-empty input is found. The tokenizer then splits the input into tokens by matching it to regular expressions. When scanner reaches the End-of-file, it throws an error to the tokenizer, which sends a null token back to the parser. The parser also builds the SExpression tree incrementally, which is explained below. When a complete SExpression is found, it returns back to the controller.

The SExpression tree:
The parser builds the SExpression tree incrementally. The tree can contain nodes of type Atom or ComplexSExpression. Atom is either a literal or a numeric atom. ComplexSExpression contains a left child and right child, which can be Atoms or complex expressions. In addition, it carries a flag which denotes whether the node is part of a list. Brackets and DOTs are not part the parse tree. The NIL atom indicating the last item of the list is stored as a null object, which I felt is easier to handle. Building the tree: A stack is maintained which contains the path from root to the current node in processing, with current node at top. When an open bracket is encountered at any point, it denotes the beginning of a new ComplexSExpression, which is added to the stack. The first element after bracket is its left child of the node in the top of the tree. If the next element is separated by a DOT, it is placed as the right child of the node in the top of the stack. If the next element is separated by a space, then a new complex expression is created, pushed to the stack and the element is placed as its left child. When a close bracket is encountered, it denotes the end of an SExpression. The tree is then backtracked to the position where the next element will be placed - this means the stack is adjusted to contain the parent of the current completed SExpression at the top. The isList flag of every node in the way back is calculated - if the right child is null or is a list, then the node is a list too.

Evaluation of expression:
Atom expressions are evaluated to their value. If the atom turns out to be a literal atom, then the variable value is looked up in the association list and is returned back. If the variable is not found, it is an error. For evaluation of complex SExpressions, the function name is the key to decide further flow of logic. If the function is an inbuilt function, the inbuilt function handler is called to execute the construct, response of which is returned back to the caller. Every inbuilt function call is checked for parameter count mismatch and the type of parameters provided. If any of the parameters turns out to be function calls, the evaluator is called to get the function call processed and the result is used in place of the parameter. If the function is DEFUN, it is added to the global definition list after performing validations. If the function turns out to be a user defined function, as a first step, parameter count is verified and they are added to the local association list to be used in execution. The function body is then sent with the new association list to the evaluator for execution. The types of parameters are not explicitly verified as they will untimately use inbuilt functions for computation, which performs type checking. Any error encountered is thrown all the way back to the controller.